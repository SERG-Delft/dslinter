<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pytorch Call Method Misused | DSLinter - Linter for Machine Learning - Specific Code Smells</title><meta name=keywords content="api-specific,model training,robustness"><meta name=description content="Use self.net() in PyTorch to forward the input to the network instead of self.net.forward()."><meta name=author content><link rel=canonical href=https://hynn01.github.io/dslinter/posts/codesmells/20-pytorch-call-method-misused/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/dslinter/assets/css/stylesheet.min.118d582b9317eeb0017c428ab7f64c4be58e68881aeb263d9b75c61866e244de.css integrity="sha256-EY1YK5MX7rABfEKKt/ZMS+WOaIga6yY9m3XGGGbiRN4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/dslinter/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://hynn01.github.io/dslinter/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hynn01.github.io/dslinter/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://hynn01.github.io/dslinter/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hynn01.github.io/dslinter/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hynn01.github.io/dslinter/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.96.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Pytorch Call Method Misused"><meta property="og:description" content="Use self.net() in PyTorch to forward the input to the network instead of self.net.forward()."><meta property="og:type" content="article"><meta property="og:url" content="https://hynn01.github.io/dslinter/posts/codesmells/20-pytorch-call-method-misused/"><meta property="article:section" content="posts"><meta property="og:site_name" content="DSLinter - Linter for Machine Learning Application - Specific Code Smells"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pytorch Call Method Misused"><meta name=twitter:description content="Use self.net() in PyTorch to forward the input to the network instead of self.net.forward()."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hynn01.github.io/dslinter/posts/"},{"@type":"ListItem","position":2,"name":"Code Smells","item":"https://hynn01.github.io/dslinter/posts/codesmells/"},{"@type":"ListItem","position":3,"name":"Pytorch Call Method Misused","item":"https://hynn01.github.io/dslinter/posts/codesmells/20-pytorch-call-method-misused/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Pytorch Call Method Misused","name":"Pytorch Call Method Misused","description":"Use self.net() in PyTorch to forward the input to the network instead of self.net.forward().","keywords":["api-specific","model training","robustness"],"articleBody":"Description Context Both self.net() and self.net.forward() can be used to forward the input into the network in PyTorch.\nProblem In PyTorch, self.net() and self.net.forward() are not identical. The self.net() also deals with all the register hooks, which would not be considered when calling the plain .forward().\nSolution It is recommended to use self.net() rather than self.net.forward().\nType API-Specific\nExisting Stage Model Training\nEffect Robustness\nExample ### PyTorch # 1. Load and normalize CIFAR10 import torch import torchvision import torchvision.transforms as transforms  transform = transforms.Compose(  [transforms.ToTensor(),  transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])  batch_size = 4  trainset = torchvision.datasets.CIFAR10(root='./data', train=True,  download=True, transform=transform) trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,  shuffle=True, num_workers=0)  testset = torchvision.datasets.CIFAR10(root='./data', train=False,  download=True, transform=transform) testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,  shuffle=False, num_workers=0)  classes = ('plane', 'car', 'bird', 'cat',  'deer', 'dog', 'frog', 'horse', 'ship', 'truck')  # 2. Define a Convolutional Neural Network import torch.nn as nn import torch.nn.functional as F   class Net(nn.Module):  def __init__(self):  super().__init__()  self.conv1 = nn.Conv2d(3, 6, 5)  self.pool = nn.MaxPool2d(2, 2)  self.conv2 = nn.Conv2d(6, 16, 5)  self.fc1 = nn.Linear(16 * 5 * 5, 120)  self.fc2 = nn.Linear(120, 84)  self.fc3 = nn.Linear(84, 10)   def forward(self, x): - x = self.pool.forward(F.relu(self.conv1(x))) + x = self.pool(F.relu(self.conv1(x)))  x = self.pool(F.relu(self.conv2(x)))  x = torch.flatten(x, 1) # flatten all dimensions except batch  x = F.relu(self.fc1(x))  x = F.relu(self.fc2(x))  x = self.fc3(x)  return x   net = Net()  # 3. Define a Loss function and optimizer import torch.optim as optim  criterion = nn.CrossEntropyLoss() optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)  # 4. Train the network for epoch in range(2): # loop over the dataset multiple times   running_loss = 0.0  for i, data in enumerate(trainloader, 0):  # get the inputs; data is a list of [inputs, labels]  inputs, labels = data   # zero the parameter gradients  optimizer.zero_grad()   # forward + backward + optimize  outputs = net(inputs)  loss = criterion(outputs, labels)  loss.backward()  optimizer.step()   # print statistics  running_loss += loss.item()  if i % 2000 == 1999: # print every 2000 mini-batches  print(f'[{epoch + 1}, {i + 1:5d}] loss: {running_loss / 2000:.3f}')  running_loss = 0.0  print('Finished Training')  PATH = './cifar_net.pth' torch.save(net.state_dict(), PATH)  # 5. Test the network on the test data correct = 0 total = 0 # since we're not training, we don't need to calculate the gradients for our outputs with torch.no_grad():  for data in testloader:  images, labels = data  # calculate outputs by running images through the network  outputs = net(images)  # the class with the highest energy is what we choose as prediction  _, predicted = torch.max(outputs.data, 1)  total += labels.size(0)  correct += (predicted == labels).sum().item()  print(f'Accuracy of the network on the 10000 test images: {100 * correct // total} %') Source: Paper Grey Literature  https://github.com/IgorSusmelj/pytorch-styleguide  GitHub Commit Stack Overflow Documentation ","wordCount":"439","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://hynn01.github.io/dslinter/posts/codesmells/20-pytorch-call-method-misused/"},"publisher":{"@type":"Organization","name":"DSLinter - Linter for Machine Learning - Specific Code Smells","logo":{"@type":"ImageObject","url":"https://hynn01.github.io/dslinter/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hynn01.github.io/dslinter/ accesskey=h title="DSLinter - Linter for Machine Learning - Specific Code Smells (Alt + H)">DSLinter - Linter for Machine Learning - Specific Code Smells</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://hynn01.github.io/dslinter/posts/codesmells/ title="Code Smells"><span>Code Smells</span></a></li><li><a href=https://hynn01.github.io/dslinter/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://hynn01.github.io/dslinter/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hynn01.github.io/dslinter/>Home</a>&nbsp;»&nbsp;<a href=https://hynn01.github.io/dslinter/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://hynn01.github.io/dslinter/posts/codesmells/>Code Smells</a></div><h1 class=post-title>Pytorch Call Method Misused</h1><div class=post-meta></div></header><div class=post-content><h3 id=description>Description<a hidden class=anchor aria-hidden=true href=#description>#</a></h3><h4 id=context>Context<a hidden class=anchor aria-hidden=true href=#context>#</a></h4><p>Both <code>self.net()</code> and <code>self.net.forward()</code> can be used to forward the input into the network in PyTorch.</p><h4 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h4><p>In PyTorch, <code>self.net()</code> and <code>self.net.forward()</code> are not identical. The <code>self.net()</code> also deals with all the register hooks, which would not be considered when calling the plain <code>.forward()</code>.</p><h4 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h4><p>It is recommended to use <code>self.net()</code> rather than <code>self.net.forward()</code>.</p><h3 id=type>Type<a hidden class=anchor aria-hidden=true href=#type>#</a></h3><p>API-Specific</p><h3 id=existing-stage>Existing Stage<a hidden class=anchor aria-hidden=true href=#existing-stage>#</a></h3><p>Model Training</p><h3 id=effect>Effect<a hidden class=anchor aria-hidden=true href=#effect>#</a></h3><p>Robustness</p><h3 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>### PyTorch
</span></span><span style=display:flex><span># 1. Load and normalize CIFAR10
</span></span><span style=display:flex><span>import torch
</span></span><span style=display:flex><span>import torchvision
</span></span><span style=display:flex><span>import torchvision.transforms as transforms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>transform = transforms.Compose(
</span></span><span style=display:flex><span>    [transforms.ToTensor(),
</span></span><span style=display:flex><span>     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>batch_size = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>trainset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=True,
</span></span><span style=display:flex><span>                                        download=True, transform=transform)
</span></span><span style=display:flex><span>trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,
</span></span><span style=display:flex><span>                                          shuffle=True, num_workers=0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>testset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=False,
</span></span><span style=display:flex><span>                                       download=True, transform=transform)
</span></span><span style=display:flex><span>testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,
</span></span><span style=display:flex><span>                                         shuffle=False, num_workers=0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>classes = (&#39;plane&#39;, &#39;car&#39;, &#39;bird&#39;, &#39;cat&#39;,
</span></span><span style=display:flex><span>           &#39;deer&#39;, &#39;dog&#39;, &#39;frog&#39;, &#39;horse&#39;, &#39;ship&#39;, &#39;truck&#39;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># 2. Define a Convolutional Neural Network
</span></span><span style=display:flex><span>import torch.nn as nn
</span></span><span style=display:flex><span>import torch.nn.functional as F
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class Net(nn.Module):
</span></span><span style=display:flex><span>    def __init__(self):
</span></span><span style=display:flex><span>        super().__init__()
</span></span><span style=display:flex><span>        self.conv1 = nn.Conv2d(3, 6, 5)
</span></span><span style=display:flex><span>        self.pool = nn.MaxPool2d(2, 2)
</span></span><span style=display:flex><span>        self.conv2 = nn.Conv2d(6, 16, 5)
</span></span><span style=display:flex><span>        self.fc1 = nn.Linear(16 * 5 * 5, 120)
</span></span><span style=display:flex><span>        self.fc2 = nn.Linear(120, 84)
</span></span><span style=display:flex><span>        self.fc3 = nn.Linear(84, 10)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    def forward(self, x):
</span></span><span style=display:flex><span><span style=color:#f92672>-     	x = self.pool.forward(F.relu(self.conv1(x)))
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+       x = self.pool(F.relu(self.conv1(x)))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>        x = self.pool(F.relu(self.conv2(x)))
</span></span><span style=display:flex><span>        x = torch.flatten(x, 1) # flatten all dimensions except batch
</span></span><span style=display:flex><span>        x = F.relu(self.fc1(x))
</span></span><span style=display:flex><span>        x = F.relu(self.fc2(x))
</span></span><span style=display:flex><span>        x = self.fc3(x)
</span></span><span style=display:flex><span>        return x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>net = Net()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># 3. Define a Loss function and optimizer
</span></span><span style=display:flex><span>import torch.optim as optim
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>criterion = nn.CrossEntropyLoss()
</span></span><span style=display:flex><span>optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># 4. Train the network
</span></span><span style=display:flex><span>for epoch in range(2):  # loop over the dataset multiple times
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    running_loss = 0.0
</span></span><span style=display:flex><span>    for i, data in enumerate(trainloader, 0):
</span></span><span style=display:flex><span>        # get the inputs; data is a list of [inputs, labels]
</span></span><span style=display:flex><span>        inputs, labels = data
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        # zero the parameter gradients
</span></span><span style=display:flex><span>        optimizer.zero_grad()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        # forward + backward + optimize
</span></span><span style=display:flex><span>        outputs = net(inputs)
</span></span><span style=display:flex><span>        loss = criterion(outputs, labels)
</span></span><span style=display:flex><span>        loss.backward()
</span></span><span style=display:flex><span>        optimizer.step()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        # print statistics
</span></span><span style=display:flex><span>        running_loss += loss.item()
</span></span><span style=display:flex><span>        if i % 2000 == 1999:    # print every 2000 mini-batches
</span></span><span style=display:flex><span>            print(f&#39;[{epoch + 1}, {i + 1:5d}] loss: {running_loss / 2000:.3f}&#39;)
</span></span><span style=display:flex><span>            running_loss = 0.0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(&#39;Finished Training&#39;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PATH = &#39;./cifar_net.pth&#39;
</span></span><span style=display:flex><span>torch.save(net.state_dict(), PATH)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># 5. Test the network on the test data
</span></span><span style=display:flex><span>correct = 0
</span></span><span style=display:flex><span>total = 0
</span></span><span style=display:flex><span># since we&#39;re not training, we don&#39;t need to calculate the gradients for our outputs
</span></span><span style=display:flex><span>with torch.no_grad():
</span></span><span style=display:flex><span>    for data in testloader:
</span></span><span style=display:flex><span>        images, labels = data
</span></span><span style=display:flex><span>        # calculate outputs by running images through the network
</span></span><span style=display:flex><span>        outputs = net(images)
</span></span><span style=display:flex><span>        # the class with the highest energy is what we choose as prediction
</span></span><span style=display:flex><span>        _, predicted = torch.max(outputs.data, 1)
</span></span><span style=display:flex><span>        total += labels.size(0)
</span></span><span style=display:flex><span>        correct += (predicted == labels).sum().item()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(f&#39;Accuracy of the network on the 10000 test images: {100 * correct // total} %&#39;)
</span></span></code></pre></div><h3 id=source>Source:<a hidden class=anchor aria-hidden=true href=#source>#</a></h3><h4 id=paper>Paper<a hidden class=anchor aria-hidden=true href=#paper>#</a></h4><h4 id=grey-literature>Grey Literature<a hidden class=anchor aria-hidden=true href=#grey-literature>#</a></h4><ul><li><a href=https://github.com/IgorSusmelj/pytorch-styleguide>https://github.com/IgorSusmelj/pytorch-styleguide</a></li></ul><h4 id=github-commit>GitHub Commit<a hidden class=anchor aria-hidden=true href=#github-commit>#</a></h4><h4 id=stack-overflow>Stack Overflow<a hidden class=anchor aria-hidden=true href=#stack-overflow>#</a></h4><h4 id=documentation>Documentation<a hidden class=anchor aria-hidden=true href=#documentation>#</a></h4></div><footer class=post-footer><ul class=post-tags><li><a href=https://hynn01.github.io/dslinter/tags/api-specific/>api-specific</a></li><li><a href=https://hynn01.github.io/dslinter/tags/model-training/>model training</a></li><li><a href=https://hynn01.github.io/dslinter/tags/robustness/>robustness</a></li></ul><nav class=paginav><a class=prev href=https://hynn01.github.io/dslinter/posts/codesmells/19-tensorarray-not-used/><span class=title>« Prev Page</span><br><span>TensorArray Not Used</span></a>
<a class=next href=https://hynn01.github.io/dslinter/posts/codesmells/21-training-evaluation-mode-improper-toggling/><span class=title>Next Page »</span><br><span>Training / Evaluation Mode Improper Toggling</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://hynn01.github.io/dslinter/>DSLinter - Linter for Machine Learning - Specific Code Smells</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>